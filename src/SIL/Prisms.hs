{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE InstanceSigs #-}

-- |All of these functions were generated by `Control.Lens.Combinators.makePrisms` with
--  a non-recursive-schemes ParserTerm data definition. `Fix` added manually where needed.
module SIL.Prisms where

import Data.Functor.Foldable
import Control.Lens.Combinators
import SIL

-- instance Traversable (ParserTerm l v) where
--   traverse _ (Fix TZero) = pure (Fix TZero)
--   traverse f (Fix (TPair a b)) = Fix . TPair <$> traverse f a <*> traverse f b
--   traverse a b = undefined


_TZero ::
  forall l_a3no v_a3np. Prism' (ParserTerm l_a3no v_a3np) ()
_TZero
  = (prism (\ () -> (Fix TZero)))
      (\ x_a9xg
         -> case x_a9xg of
              (Fix TZero) -> Right ()
              _ -> Left x_a9xg)
_TPair ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np,
                                     ParserTerm l_a3no v_a3np)
_TPair
  = (prism (\ (x1_a9xh, x2_a9xi) -> Fix $ TPair x1_a9xh x2_a9xi))
      (\ x_a9xj
         -> case x_a9xj of
              (Fix (TPair y1_a9xk y2_a9xl)) -> Right (y1_a9xk, y2_a9xl)
              _ -> Left x_a9xj)
_TVar ::
  forall l_a3no v_a3np. Prism' (ParserTerm l_a3no v_a3np) v_a3np
_TVar
  = (prism (\ x1_a9xm -> Fix $ TVar x1_a9xm))
      (\ x_a9xn
         -> case x_a9xn of
              (Fix (TVar y1_a9xo)) -> Right y1_a9xo
              _ -> Left x_a9xn)
_TApp ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np,
                                     ParserTerm l_a3no v_a3np)
_TApp
  = (prism (\ (x1_a9xp, x2_a9xq) -> Fix $ TApp x1_a9xp x2_a9xq))
      (\ x_a9xr
         -> case x_a9xr of
              (Fix (TApp y1_a9xs y2_a9xt)) -> Right (y1_a9xs, y2_a9xt)
              _ -> Left x_a9xr)
_TCheck ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np,
                                     ParserTerm l_a3no v_a3np)
_TCheck
  = (prism (\ (x1_a9xu, x2_a9xv) -> Fix $ TCheck x1_a9xu x2_a9xv))
      (\ x_a9xw
         -> case x_a9xw of
              (Fix (TCheck y1_a9xx y2_a9xy)) -> Right (y1_a9xx, y2_a9xy)
              _ -> Left x_a9xw)
_TITE ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np,
                                     ParserTerm l_a3no v_a3np, ParserTerm l_a3no v_a3np)
_TITE
  = (prism
       (\ (x1_a9xz, x2_a9xA, x3_a9xB)
          -> Fix $ TITE x1_a9xz x2_a9xA x3_a9xB))
      (\ x_a9xC
         -> case x_a9xC of
              (Fix (TITE y1_a9xD y2_a9xE y3_a9xF)) -> Right (y1_a9xD, y2_a9xE, y3_a9xF)
              _ -> Left x_a9xC)
_TLeft ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np)
_TLeft
  = (prism (\ x1_a9xG -> Fix $ TLeft x1_a9xG))
      (\ x_a9xH
         -> case x_a9xH of
              (Fix (TLeft y1_a9xI)) -> Right y1_a9xI
              _ -> Left x_a9xH)
_TRight ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np)
_TRight
  = (prism (\ x1_a9xJ -> Fix $ TRight x1_a9xJ))
      (\ x_a9xK
         -> case x_a9xK of
              (Fix (TRight y1_a9xL)) -> Right y1_a9xL
              _ -> Left x_a9xK)
_TTrace ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (ParserTerm l_a3no v_a3np)
_TTrace
  = (prism (\ x1_a9xM -> Fix $ TTrace x1_a9xM))
      (\ x_a9xN
         -> case x_a9xN of
              (Fix (TTrace y1_a9xO)) -> Right y1_a9xO
              _ -> Left x_a9xN)
_TLam ::
  forall l_a3no v_a3np.
  Prism' (ParserTerm l_a3no v_a3np) (LamType l_a3no,
                                     ParserTerm l_a3no v_a3np)
_TLam
  = (prism (\ (x1_a9xP, x2_a9xQ) -> Fix $ TLam x1_a9xP x2_a9xQ))
      (\ x_a9xR
         -> case x_a9xR of
              (Fix (TLam y1_a9xS y2_a9xT)) -> Right (y1_a9xS, y2_a9xT)
              _ -> Left x_a9xR)
_TLimitedRecursion ::
  forall l_a3no v_a3np. Prism' (ParserTerm l_a3no v_a3np) ()
_TLimitedRecursion
  = (prism (\ () -> Fix TLimitedRecursion))
      (\ x_a9xU
         -> case x_a9xU of
              (Fix TLimitedRecursion) -> Right ()
              _ -> Left x_a9xU)
